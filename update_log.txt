2026.1.20.21.17
没有好说的,重构 ctype.h
23.24
重构了fcntl.h,折成了3个文件,还有一个还没完全可以实现的.我觉得有的地方 char 可能更好,所以我又改了改.
对文件名类型选择使用string_view,你可能会说,哎呀,cahr * 更快, 但是真正的性能瓶颈应该是像缺页错误那种吧
string_view 与 const char* 也就纳秒级差异 相对缺页错误 一言不和就微秒级,毫秒级延迟
这个string_view 与 const char* 可以略了
所以 类型安全性和代码可维护性 应该成为主要考虑因素,而不是微观的性能差异....
哦,对了,因为内核环境不太可以用STL,所以我自己写了一个.
0.30
实际上不太重要,因为我只是因为好玩,我告诉你我不会用做什么内核.
所以我又改了回来.这是让人知道....
但是不能为了使用cpp新特性就去使用cpp.
要在我觉得和适的地方用
2026.1.19.23.09
我完成了const.h的重构,因为有的东西,现在还不可以实现..所以就放在temp.txt了
把文件类型枚举拆分了
- 内核空间 ： kernel_file_type 枚举（内核专用）
- 用户空间 ： user_file_type 枚举（用户空间专用）
emmmmmmm,还有修了两个设计问题.反正
file_permissions_type支持多个权限了...
还有一些奇怪的被 #if 0 的代码.那都是废品...emmmmm,更多是ai写的,让我感觉非常2b的代码.
可能为了突现我(代码)的优势吧.
2026.1.18.13.19
把type.h分了一下,增加了
file_information_statistics.h,改进了变量名
我觉得还不错
2026.1.18.11.11
我增加了三个文件
relocation_information.h
symbol_table.h
symbol_type.h
这可能是不太好?
我应该把
relocation_information.h,symbol_table.h
加到executable_header.h?
还有,原来的0.01怎么还没有 调试符号类型...
好吧,上面的新文件我觉得可能还好.就是不太太让人与
executable_header.h关连起来?
symbol_table.h,symbol_type.h,关系性还是很高的一眼让人看出来
符号类型信息又是一个变量存怎么多东西,我优化了一下下
    /**
     * 符号类型信息
     */
    symbol_main_type main_type;      // 当前使用的符号主要类型
    symbol_type_union type;          // 符号类型联合，共享1字节内存
还去掉了| & 的开悄,直接 == 对比
大约用了1.5h.还是不错
emmmmmmm,我还要继续后写吗,那这次更新的是不是太少了,文章是不是没什么写的?
当我怎么想的时侯,我就应该直接去打游戏了,我为理解 重定位信息,符号表,还有那一变多用,
说实话
    uint32_t symbolnum : 24; /* 符号索引或段类型 */
    uint32_t is_relative_offset : 1;      /* 是否为PC相对偏移 */
    uint32_t relocation_length : 2;     /* 重定位字段长度（2的指数） */
    uint32_t extern_flag : 1;     /* 使用符号值还是段地址 */
    uint32_t retention_bit : 4;        /* 保留位 */
这种 uint32_t ...:...
比一变多用好多了,我的新语言lmna应该这种支持好点,防止一变多用....
然后也没什么么了
2026.1.17.20.58
我基本放弃了原来的linux0.01的架构,我觉得那个太有问题了,还有名字,什么time.h,times.h,....看的让人头大!
linux
├── include/
│   ├── error.h                  # 全局错误定义
│   ├── type.h                   # 底层类型定义
|   |── executable_header.h      # 二进型文件定义
│   ├── file/                    # 文件相关头文件
│   │   ├── file_error.h         # 文件错误定义
│   │   └── file_status.h        # 文件状态结构体
│   ├── process/                 # 进程相关头文件
│   │   ├── pricess_error.h      # 进程错误定义
│   │   ├── process_status.h     # 进程状态
│   │   ├── process_time.h       # 进程时间
│   │   └── process_wait.h       # 进程等待
│   └── system/                  # 系统相关头文件
│       ├── system_error.h       # 系统错误
│       └── system_name.h        # 系统名称
└── linux.cpp                    # 主源文件
主要因为我发现有的地方很奇怪....

2026.1.17.11.18
重写了stat.h,error.h,改进了错误码定义，使其更清晰易读...
还有error,全局变量,我还是觉得不错...
2026.1.17.9.15
我刚刚重写完了include > sys > types.h 文件
但是我发现,这个type里面什么都有,各种东西,还有古老的
#ifndef _SIZE_T
#define _SIZE_T
这种东西,后面我会把int_div_t ustat 分开来,甚至多几个type.h
实现进程,时间,文件的类型定义...
还有我用cpp是因为我觉得他的有些东西可以更好的资源管理,且我写的比原来的还多几倍

是的,我觉得他非常底层,所以要先实现type.h
2026.1.16.22.21 曰记
我承认我是一个傻逼,妈的想用linux0.01的镜像....
太傻逼了,真的让人红温,还有代码里让人看着就想死的各种宏
我觉得 namespace constexpr using inline & && 太伟大了
不然我就像老一辈程序员一样吃屎了

所以我准备重写linux0.01,我觉得这会非常非常有意思

但是我理论上要很多知识,但是 ctrl C ctrl V 加注释就okk了
我可能也不创镜像,我只是非常想写代码
...